//----------------------------------------------------------------------------------------
// patterns & practices - Smart Client Software Factory - Guidance Package
//
// This file was generated by this guidance package as part of the solution template
//
// For more information see: 
// ms-help://MS.VSCC.v80/MS.VSIPCC.v80/ms.scsf.2006jun/SCSF/html/03-210-Creating%20a%20Smart%20Client%20Solution.htm
//
// Latest version of this Guidance Package: http://go.microsoft.com/fwlink/?LinkId=62182
//----------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Threading;
using Microsoft.Practices.EnterpriseLibrary.ExceptionHandling;

namespace ACOT.Infrastructure.Interface.Commands
{
    public class CommandQueue
    {
        Queue<ICommand> _commandQueue;
        AutoResetEvent _newCommandsEvent = new AutoResetEvent(false);
        object _lockObject = new object();

        public CommandQueue()
        {
            _commandQueue = new Queue<ICommand>();
        }

        public WaitHandle NewCommandWaitHandle
        {
            get { return _newCommandsEvent; }
        }

        public void Add(ICommand command)
        {
            lock (_lockObject)
                _commandQueue.Enqueue(command);

            _newCommandsEvent.Set();
        }

        public void Run()
        {
            ICommand command;

            while (TryGetNextCommand(out command))
            {
                try
                {
                    command.Execute();
                }
                catch (Exception ex)
                {
                    ExceptionPolicy.HandleException(ex, "Default Policy");
                }

                IDisposable disp = command as IDisposable;

                if (disp != null)
                    disp.Dispose();
            }
        }

        private bool TryGetNextCommand(out ICommand command)
        {
            command = null;

            lock (_lockObject)
            {
                if (_commandQueue.Count > 0)
                    command = _commandQueue.Dequeue();
            }

            return (command != null);
        }
    }
}
