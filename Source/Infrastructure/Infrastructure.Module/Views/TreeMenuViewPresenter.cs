//----------------------------------------------------------------------------------------
// patterns & practices - Smart Client Software Factory - Guidance Package
//
// This file was generated by the "Add Foundational Module" recipe.
//
// The LayoutView usercontrol defines a layout decoupled from the shell. 
// It provides a left and right workspace, menu bar, tool bar and status bar.
// These ui elements are added as extension sites.
//
// For more information see:
// ms-help://MS.VSCC.v80/MS.VSIPCC.v80/ms.practices.scsf.2007may/SCSF/html/03-01-030-How_to_Create_a_Foundational_Module.htm
//
// Latest version of this Guidance Package: http://go.microsoft.com/fwlink/?LinkId=62182
//----------------------------------------------------------------------------------------

using System;
using System.Collections.ObjectModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Windows.Forms;
using ACOT.Infrastructure.Controls.TreeViewAdvanced;
using ACOT.Infrastructure.Interface;
using ACOT.Infrastructure.Interface.Data;
using ACOT.Infrastructure.Interface.Services;
using ACOT.Infrastructure.Module.Constants;
using Microsoft.Practices.CompositeUI;
using Microsoft.Practices.CompositeUI.EventBroker;

namespace ACOT.Infrastructure.Module.Views
{
    public partial class TreeMenuViewPresenter : Presenter<ITreeMenuView>
    {
        private const string _treeConfigFileName = "\\Tree.config";
        private TreeModel _treeModel;

        [ServiceDependency]
        public IContextService context
        {
            get;
            set;
        }

        /// <summary>
        /// Close the view
        /// </summary>
        public void OnCloseView()
        {
            base.CloseView();
        }

        protected override void OnViewSet()
        {
            // Установка значений по-умолчанию для формы
            View.Tree.Font = context.Font;

            View.View.Load += new EventHandler(TreeMenuView_Load);

            base.OnViewSet();
        }

        private void TreeMenuView_Load(object sender, EventArgs e)
        {
            View.View.ParentForm.FormClosing += new FormClosingEventHandler(ParentForm_FormClosing);
            string cfg = Application.StartupPath + _treeConfigFileName;
            if (File.Exists(cfg))
            {
                StreamReader sr = new StreamReader(cfg);
                string buf;
                while (!sr.EndOfStream)
                {
                    buf = sr.ReadLine();
                    foreach (TreeNodeAdv tn in View.Tree.AllNodes)
                    {
                        Node node = (Node) tn.Tag;
                        if (node.Tag.ToString() == buf)
                        {
                            tn.Expand();
                            break;
                        }
                        else
                            ExpandNode(buf, tn);
                    }
                }
                sr.Close();
            }
            IPerfomanceService perf = WorkItem.RootWorkItem.Services.Get<IPerfomanceService>();
            perf.stopwatch.Stop();

            double t = perf.stopwatch.ElapsedMilliseconds/1000;
            //this.layout.ParentForm.Text = "Запуск ACOTWIN за " + t.ToString() + " s";                       
        }

        [EventPublication(EventTopicNames.MainMenuClick, PublicationScope.Global)]
        public event EventHandler<EventArgs<string>> OnMainMenuClick;

        [EventPublication(EventTopicNames.MainMenuKeyDown, PublicationScope.Global)]
        public event EventHandler<EventArgs<string>> OnMainMenuKeyDown;

        internal void TreeClick(string s)
        {
            if (OnMainMenuClick != null)
                OnMainMenuClick(this, new EventArgs<string>(s));
        }

        internal void ViewLST(string p)
        {
            //if (OnMainMenuKeyDown != null)
            //    OnMainMenuKeyDown(this, new EventArgs<string>(p));            
            DataRow[] rows = context.menuData._mainMenu.Select("ID=" + p);
            if (rows != null)
            {
                string paras = "";
                string buf = "";
                MenuData._mainMenuRow row = (MenuData._mainMenuRow) rows[0];

                if (!row.IsCMD1Null()) paras += row.CMD1 + "|";
                if (!row.IsCMD2Null()) paras += row.CMD2 + "|";
                if (!row.IsCMD3Null()) paras += row.CMD3 + "|";
                if (!row.IsCMD4Null()) paras += row.CMD4 + "|";
                if (!row.IsCMD5Null()) paras += row.CMD5 + "|";

                if (paras.Contains("*.ls"))
                {
                    // Получаем маску файлов
                    int idx = paras.IndexOf("*.ls");
                    while (paras[idx] != ' ') idx--;
                    idx++;
                    while (paras[idx] != ' ') buf += paras[idx++];
                }
                if (buf != "")
                    ScanDir(buf);
            }
        }

        internal void FillTree()
        {
            // Заменили компонент TreeView на  TreeViewAdvanced. Так как этот компонент
            // использует архитектуру Model-View, будем работать с моделью.
            _treeModel = new TreeModel();
            foreach (MenuData._mainMenuRow row in context.menuData._mainMenu.Rows)
            {
                Node newNode = new Node();
                newNode.Tag = row.ID;
                newNode.Text = row.NAME.Replace("&", "");

                //newNode.ToolTipText = row.IsTIPNull() == true ? "" : row.TIP;

                string buf = newNode.Tag.ToString();
                buf = "0" + buf.Remove(buf.Length - 1);

                Node parentNode = FindNode(_treeModel.Nodes, buf);
                if (parentNode != null)
                {
                    parentNode.Nodes.Add(newNode);
                }
                else
                    _treeModel.Nodes.Add(newNode);
            }
            View.Tree.Model = _treeModel;
        }

        /// <summary>
        /// Метод возвращает родителя элемента Node. В значении тега заменяется на ноль последни знак.
        /// </summary>
        /// <param name="nodes">Значение типа Список элементов дерева</param>
        /// <param name="key">Значение типа строка. Содержит код родителя текущего node</param>
        /// <returns></returns>
        private Node FindNode(Collection<Node> nodes, string key)
        {
            foreach (Node node in nodes)
            {
                if (node.Tag.ToString() == key)
                    return node;

                if (node.Nodes.Count != 0)
                {
                    Node tn = FindNode(node.Nodes, key);
                    if (tn != null)
                        return tn;
                }
            }
            return null;
        }

        private void ScanDir(string buf)
        {
            IFilesWalker walker = WorkItem.RootWorkItem.Services.Get<IFilesWalker>();
            FileInfo[] fi = walker.GetFilesList(buf);

            if (fi.Length != 0)
            {
                string batname = context.startupDir + "\\start.bat";
                StreamWriter sw = new StreamWriter(batname);
                sw.WriteLine("@view.exe " + buf + " pe.exe");
                sw.WriteLine("@exit");
                sw.Close();
                string startupDir = Directory.GetCurrentDirectory();
                Directory.SetCurrentDirectory(context.startupDir);
                Process.Start(batname);
                Directory.SetCurrentDirectory(startupDir);
                //File.Delete(batname);
            }
            else
                MessageBox.Show("Не найдены листинги с именами " + buf, "ACOT");
        }

        private bool ExpandNode(string key, TreeNodeAdv treeNode)
        {
            foreach (TreeNodeAdv tn in treeNode.Children)
            {
                Node node = (Node) tn.Tag;
                if (tn.Tag.ToString() == key)
                {
                    tn.Expand();
                    return true;
                }

                if (tn.Children.Count != 0)
                    if (ExpandNode(key, tn))
                        return true;
            }
            return false;
        }

        public void ParentForm_FormClosing(object sender, EventArgs e)
        {
            Collection<object> list = new Collection<object>();

            foreach (TreeNodeAdv tn in View.Tree.AllNodes)
            {
                if (tn.IsExpanded)
                    list.Add(tn.Tag);

                if (tn.Children.Count != 0)
                    TreeTour(tn, list);
            }

            StreamWriter sw = new StreamWriter(Application.StartupPath + _treeConfigFileName);

            foreach (Node s in list)
            {
                sw.WriteLine(s.Tag.ToString());
            }
            sw.Close();
        }

        private void TreeTour(TreeNodeAdv _tn, Collection<object> list)
        {
            foreach (TreeNodeAdv tn in _tn.Children)
            {
                if (tn.IsExpanded)
                    list.Add(tn.Tag);

                if (tn.Children.Count != 0)
                    TreeTour(tn, list);
            }
        }
    }
}